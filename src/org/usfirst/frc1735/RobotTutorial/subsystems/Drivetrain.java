// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.RobotTutorial.subsystems;

import org.usfirst.frc1735.RobotTutorial.RobotMap;
import org.usfirst.frc1735.RobotTutorial.commands.*;
import org.usfirst.frc1735.RobotTutorial.Robot;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Victor;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Drivetrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController speedControllerL = RobotMap.drivetrainSpeedControllerL;
    private final SpeedController speedControllerR = RobotMap.drivetrainSpeedControllerR;
    private final RobotDrive robotDrive21 = RobotMap.drivetrainRobotDrive21;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoysticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    
    public void selectableDriveWithJoysticks(Joystick joyLeft, Joystick joyRight) {
		// Extract the joystick values
		double joyLeftX, joyLeftY, joyRightX, joyRightY;
		
		// If an Xbox controller, Use the two sticks on controller 1 (Right side) instead of using two discrete joysticks
		if (joyRight.getIsXbox()) {
			joyLeftX = joyRight.getRawAxis(0);  // Left stick X
			joyLeftY = joyRight.getRawAxis(1);  // Left stick Y
			joyRightX = joyRight.getRawAxis(4); // Right stick X
			joyRightY = joyRight.getRawAxis(5); // Right stick Y
		}
		else {
			// Here, use the two discrete joysticks.
			joyLeftX  = joyLeft.getX();
			joyLeftY  = joyLeft.getY();
			joyRightX = joyRight.getX();
			joyRightY = joyRight.getY();
		}
		// Print the raw joystick inputs
		//System.out.println("joyLeftY="+joyLeftY+" joyLeftX="+joyLeftX + " joyRightY="+joyRightY+" joyRightX="+joyRightX);

		// Apply the 'dead zone' guardband to the joystick inputs:
		// Centered joysticks may not actually read as zero due to spring variances.
		// Therfore, remove any small values as being "noise".
		// Because we may need to adjust this, make it settable by the user via the Smart Dashboard.
		double joystickDeadzone = SmartDashboard.getNumber("Joystick Deadzone", 0); // default to zero if entry not found
		if (Math.abs(joyLeftX) < joystickDeadzone)
			joyLeftX = 0;
		if (Math.abs(joyLeftY) < joystickDeadzone)
			joyLeftY = 0;
		if (Math.abs(joyRightX) < joystickDeadzone)
			joyRightX = 0;
		if (Math.abs(joyRightY) < joystickDeadzone)
			joyRightY = 0;
		
		// Find out which operating mode is requested
		if (this.isInTankMode()) { // Use the accessor function instead of the variable, so that if the implementation changes we only have to touch one place.
			// Tank mode assumes(?) non-joystick (fwd = positive)
			this.tankDrive(-joyLeftY, -joyRightY); //left fwd/rvs, right fwd/rvs.  On joystick, Y up is negative.
		}
		else if (this.isInArcadeMode()) { // Could have just been an "else" but this way the code is agnostic of the underlying implementation/modes.  allows us to change implementations in just one place.
			// In arcade mode, the underlying WPILIB code assumes joystick input values (Y up = neg) for forward
			this.arcadeDrive(joyRightY, joyRightX); // fwd/rvs, rotation (CW/right is negative)
		}
		else {
			// We should never get here since we currently only have two modes of operation.  But, just in case, let's print an error to the screen so the user knows something went wrong
			System.err.println("ERROR: Drivetrain.selectableDriveWithJoysticks got an illegal drive mode state (not tank and not arcade)!  Resetting to Tank mode as a recovery mechanism");
			this.setTankMode();
			this.tankDrive(-joyLeftY, -joyRightY); //left fwd/rvs, right fwd/rvs.  On joystick, Y up is negative.
		}
    }
    
    // Function for handling tank drive.  This is a wrapper in case we ever need to do something specific in tank mode.
    public void tankDrive(double leftMagDir, double rightMagDir) {
    	robotDrive21.tankDrive(leftMagDir, rightMagDir);
    }
    
    // Function for handling arcade drive.  This is a wrapper in case we ever need to do something specific in arcade mode.
    public void arcadeDrive(double moveValue,double rotateValue) {
    	robotDrive21.arcadeDrive(moveValue, rotateValue); //Asssume joystick inputs (Y fwd == -1)
    	
    }
    	
    // Function to STOP the drivetrain:
    public void stop() {
    	// Call the WPILIB code directly so we don't change modes when stopping...
    	robotDrive21.arcadeDrive(0, 0); //move, rotate
    }

    // Accessor function in case some other part of the robot ever needs to know what mode we're in
    public boolean isInTankMode() {
    	//Simply return the state of the global variable
    	return this.m_isInTankMode;
    }
    
    public boolean isInArcadeMode() {
    	// Currently, arcade mode is the inverse of tank mode (there are only two modes)
    	// While one could simply assume everywhere that arcade = !tank, this might not be true sometime in the future if we added a third drive mode, so
    	// we provide this accessor function to protect other code uses outside of this file from implementation assumptions.
    	return !this.m_isInTankMode;
    }
    
    public void toggleDrivetrain() {
    	// While we could just invert the variable here, that would make it hard to communicate the change to the smart dashboard, and would result in duplicate code.
    	// Instead, use an 'if' and call the set functions so that we get this for "free"
    	if (this.isInTankMode()) {
    		this.setArcadeMode();
    	}
    	else if (this.isInArcadeMode()) {
    		this.setTankMode();
    	}
    	else {
    		// Should never get here, but if we do, reset to tank mode as a recovery mechanism (and inform the user)
			System.err.println("ERROR: Drivetrain.toggleDriveTrain got an illegal drive mode state (not tank and not arcade)!  Resetting to Tank mode as a recovery mechanism");
			this.setTankMode();
    	}
    }
    
    public void setTankMode() {
    	m_isInTankMode = true;
    	// Indicate new mode on the SmartDashboard
    	SmartDashboard.putString("Drivetrain Mode", "TANK");
    }
    
    public void setArcadeMode() {
    	m_isInTankMode = false;
    	// Indicate new mode on the SmartDashboard
    	SmartDashboard.putString("Drivetrain Mode", "ARCADE");
    }
    
    // Member Variables
    boolean m_isInTankMode = true; // True = Tank; False = Arcade
}

